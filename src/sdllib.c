/* ================================================================== */
/*
 * sdllib.c
 * Additional code to support SDL binding.
 *
 * This file is part of LuaSDL.
 *
 * Copyright (c) 2007 Kein-Hong Man <khman@users.sf.net>
 * The COPYRIGHT-LuaSDL file describes the conditions
 * under which this software may be distributed.
 */
/* ================================================================== */

#if defined(_WIN32)
	#ifndef LUA_BUILD_AS_DLL
	#define LUA_BUILD_AS_DLL 1
	#endif
#endif

#ifndef LUA_LIB
#define LUA_LIB 1
#endif

#include <stdlib.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include <lualib.h>

#include "SDL.h"
#include "SDL_net.h"


#include "tolua++.h"

/* for Win32 directory listing, configuration paths */
#ifdef _WIN32
#include <io.h>
#include <shlobj.h>
#include <windows.h>
#else
#include <dirent.h>
#include <sys/unistd.h>
#include <errno.h>
//#error "please add code for non-Win32..."
#endif

#include "sdllib.h"

/* header file of autogenerated binding */
#include "autogen/SDL_bind.h"

/* basic font data, bad inclusion practice, bad, bad,... */
#include "DejaVu-Sans-Mono-13.c"

/* ================================================================== */
/*
 * Using unsigned ints now, this may change if there is a persuasive
 * argument for the use of signed ints.
 */
/* ================================================================== */

#if defined(LUA_VERSION_NUM) && LUA_VERSION_NUM < 501
#error "requires Lua 5.1 or better, unless you know what you are doing"
#endif

/* holds information to be passed to LuaSDL library startup */
struct LuaSDL_StartInfo start_info;

/* ================================================================== */
/*
 * argument processing
 */
/* ================================================================== */
static int process_args(lua_State *L, char *argv[], char **app)
{
    int nargs = 0;      /* # arguments sent to script */
    *app = 0;           /* no script found at beginning */
    while (*(++argv)) {
        char c = *argv[0];
        if (c == '-' || *app) {
            luaL_checkstack(L, ++nargs, "too many arguments to script");
            lua_pushstring(L, *argv);
        } else {        /* take first non-option as main script */
            *app = *argv;
        }
    }
    return nargs;
}

/* ================================================================== */
/*
 * support functions for path processing
 */
/* ================================================================== */
/*
 * true if directory separator found, advances path, eats
 * adjacent separators
 */
int is_dir_sep(char **path)
{
    int sep = **path == '/' || **path == '\\';
    if (sep) {
        while (**path == '/' || **path == '\\') (*path)++;      /* skip */
    }
    return sep;
}
/*
 * true if DOS-style drive spec at beginning, advances path,
 * eats adjacent separators
 */
int is_drive_spec(char **path)
{
    int drv = strlen(*path) >= 3 &&     /* find <letter><colon><dir_sep> */
             isalpha(**path) &&
             (*path)[1] == ':' &&
             ((*path)[2] == '/' || (*path)[2] == '\\');
    if (drv) {                          /* skip */
        *path += 2;
        is_dir_sep(path);
    }
    return drv;
}
/*
 * true if a separator found, advances path, returns path segment
 */
int has_dir_sep(char **path, char *part)
{
    char c;
    int sep = 0;
    while ((c = **path) != '\0') {
        if ((sep = is_dir_sep(path))) break;
        *(part++) = c;
        (*path)++;
    }
    *part = '\0';
    return sep;
}
/*
 * remove a segment from a well-formed absolute path spec
 */
void remove_seg(char *path)
{
    /* find root spec */
    char *pos;
    char *root = path;
    char *last = path + strlen(path)-1;
    is_dir_sep(&root) || is_drive_spec(&root);
    /* remove trailing dir_seps */
    while (pos = last, pos >= root && is_dir_sep(&pos)) {
        *last-- = '\0';
    }
    /* remove a segment */
    while (pos = last, pos >= root && !is_dir_sep(&pos)) {
        *last-- = '\0';
    }
}

/* ================================================================== */
/*
 * Get absolute paths so that we can reliably find files. Needed
 * because LuaSDL needs to find the default script in the executable's
 * directory if nothing is specified on comment line. The absolute
 * paths are passed to the LuaSDL library so that scripts can use it.
 */
/* ================================================================== */

static int get_absolute_paths(struct LuaSDL_StartInfo *info)
{
    char c;
    size_t sz;
    char *path;
    /* platform-dependent means to get absolute paths */
#ifdef __WIN32__
    strcpy(info->dir_sep, "\\");
    GetCurrentDirectory(MAX_PATH,info->dir_cwd);
    info->dir_cwd[MAX_PATH] = '\0';
    GetModuleFileName(NULL, info->dir_exe, MAX_PATH);
    info->dir_exe[MAX_PATH] = '\0';
#else
//#error "absolute path handling not yet implemented for other platforms"
    strcpy(info->dir_sep, "/");
    getcwd(info->dir_cwd, MAX_PATH);
    info->dir_cwd[MAX_PATH] = '\0';
    readlink("/proc/self/exe", info->dir_exe, PATH_MAX);
    info->dir_exe[MAX_PATH] = '\0';
#endif
    /* ensure trailing dir_sep for dir_cwd */
    path = info->dir_cwd;
    sz = strlen(path);
    c = path[sz-1];
    if (c != '/' && c != '\\') {
        if (sz >= MAX_PATH) return 1;
        strcat(path, info->dir_sep);
    }
    /* remove filename portion for dir_exe */
    remove_seg(info->dir_exe);
    return 0;
}

/* ================================================================== */
/*
 * determine script path, mostly platform-independent
 * directory paths normalized to always have trailing dir_seps
 */
/* ================================================================== */

static int get_script_path(struct LuaSDL_StartInfo *info, char *app)
{
    char spec[MAX_PATH+1];
    char seg[MAX_PATH+1];
    char *path = info->dir_app;
    /*
     * decide on where to grab the main script from, one of:
     * (1) current working directory + script path given in argument
     * (2) executable's directory + standard init file
     */
    if (app) {
        strcpy(path, info->dir_cwd);
        strcpy(spec, app);
    } else {
        strcpy(path, info->dir_exe);
        strcpy(spec, SCRIPT_DEFAULT);
    }
    app = spec;
    /* check for absolute path specification */
    if (is_dir_sep(&app) || is_drive_spec(&app)) {
        size_t sz = app - spec;
        path[sz] = '\0';
        while (sz--) { path[sz] = spec[sz]; }
    }
    /* normalize script path if relative, last seg is actual filename */
    while(has_dir_sep(&app, seg)) {
        if (strcmp(seg, ".") == 0) {
            /* do nothing, consume the segment */
        } else if (strcmp(seg, "..") == 0) {
            /* remove a segment from the path */
            remove_seg(path);
        } else {
            /* path segment, add it to path */
            if (strlen(seg) + strlen(path) < MAX_PATH) {
                strcat(path, seg);
                strcat(path, info->dir_sep);
            } else {
                return 1;
            }
        }
    } /* end while */
    if (*seg == '\0')
        /* no final segment means no file given, use default name */
        strcpy(info->appname, SCRIPT_DEFAULT);
    else
        strcpy(info->appname, seg);
    return 0;
}

/* ================================================================== */
/*
 * protected call to main script
 */
/* ================================================================== */
static int lua_dofile(lua_State *L, const char *filename, int nargs)
{
    int status = luaL_loadfile(L, filename);
    if (status == 0) {
        lua_insert(L, -nargs-1);
        status = lua_pcall(L, nargs, 1, 0);
    }
    if (status && !lua_isnil(L, -1)) {
        const char *msg = lua_tostring(L, -1);
        if (msg == NULL) msg = "(error object is not a string)";
        fprintf(stderr, "%s\n", msg);
        fflush(stderr);
    }
    return status;
}

/* ================================================================== */
/*
 * check if file exists
 */
/* ================================================================== */
int file_exists(const char *path)
{
    FILE *h = fopen(path, "r");
    if (h) {
        fclose(h);
        return 1;
    }
    return 0;
}

/* ================================================================== */
/*
 * make absolute script path
 */
/* ================================================================== */
static int make_script_path(char *path, struct LuaSDL_StartInfo *info, char *app)
{
    if (get_script_path(info, app) ||
        strlen(info->dir_app) + strlen(info->appname) >= MAX_PATH) {
        fprintf(stderr, "Error: absolute script path too long.\n");
        fflush(stderr);
        return 1;
    }
    strcpy(path, info->dir_app);
    strcat(path, info->appname);
    return 0;
}

/* ================================================================== */
/*
 * functions that extend tolua++
 * tolua_sconstant - push string constants into a module
 * tolua_pointer - push a light user type into a module
 */
/* ================================================================== */

TOLUA_API void tolua_sconstant(lua_State* L, const char *name, const char *value)
{
    lua_pushstring(L, name);
    tolua_pushstring(L, value);
    lua_rawset(L, -3);
}

TOLUA_API void tolua_pointer(lua_State* L, const char *name, void *ptr)
{
    lua_pushstring(L, name);
    lua_pushlightuserdata(L, ptr);
    lua_rawset(L, -3);
}

/* ================================================================== */
/*
 * SDL.Bool(v)
 * - change a number (from a C int) into a Lua boolean
 */
/* ================================================================== */

static int _SDL_bool(lua_State* L)
{
    int n = luaL_checkinteger(L, 1);
    lua_pushboolean(L, n != 0);
    return 1;
}

/* ================================================================== */
/*
 * SDL.And(...)
 * - 32-bit bitwise AND
 */
/* ================================================================== */

static int SDL_and(lua_State* L)
{
    int nargs = lua_gettop(L);  /* number of arguments */
    unsigned int result = luaL_checkinteger(L, 1);
    int i;
    for (i = 2; i <= nargs; i++) {
        result = result & luaL_checkinteger(L, i);
    }
    lua_pushnumber(L, result);
    return 1;
}

/* ================================================================== */
/*
 * SDL.Or(...)
 * - 32-bit bitwise OR
 */
/* ================================================================== */

static int SDL_or(lua_State* L)
{
    int nargs = lua_gettop(L);  /* number of arguments */
    unsigned int result = luaL_checkinteger(L, 1);
    int i;
    for (i = 2; i <= nargs; i++) {
        result = result | luaL_checkinteger(L, i);
    }
    lua_pushnumber(L, result);
    return 1;
}

/* ================================================================== */
/*
 * SDL.Xor(...)
 * - 32-bit bitwise XOR
 */
/* ================================================================== */

static int SDL_xor(lua_State* L)
{
    int nargs = lua_gettop(L);  /* number of arguments */
    unsigned int result = luaL_checkinteger(L, 1);
    int i;
    for (i = 2; i <= nargs; i++) {
        result = result ^ luaL_checkinteger(L, i);
    }
    lua_pushnumber(L, result);
    return 1;
}

/* ================================================================== */
/*
 * SDL.Not(v)
 * - 32-bit bitwise NOT
 */
/* ================================================================== */

static int SDL_not(lua_State* L)
{
    unsigned int n = luaL_checkinteger(L, 1);
    lua_pushnumber(L, ~n);
    return 1;
}

/* ================================================================== */
/*
 * SDL.LShift(value, amount)
 * - 32-bit bitwise Left Shift
 */
/* ================================================================== */

static int SDL_lshift(lua_State* L)
{
    unsigned int n = luaL_checkinteger(L, 1);
    int shift = luaL_checkinteger(L, 2);
    lua_pushnumber(L, n << shift);
    return 1;
}

/* ================================================================== */
/*
 * SDL.RShift(value, amount)
 * - 32-bit bitwise Right Shift
 */
/* ================================================================== */

static int SDL_rshift(lua_State* L)
{
    unsigned int n = luaL_checkinteger(L, 1);
    int shift = luaL_checkinteger(L, 2);
    lua_pushnumber(L, n >> shift);
    return 1;
}

/* ================================================================== */
/*
 * SDL.SDL_RWFromFP(LUA_FILEHANDLE, autoclose)
 * - modified form of original SDL_RWFromFP
 * - instead of a C file handle, it takes a Lua file handle usertype
 */
/* ================================================================== */

static int _SDL_RWFromFP(lua_State* L)
{
    /* LUA_FILEHANDLE is from lualib.h */
    FILE **pf = (FILE **)luaL_checkudata(L, 1, LUA_FILEHANDLE);
    if (*pf == NULL) {
        luaL_error(L, "attempt to use a closed file");
    }
    int autoclose = luaL_checkinteger(L, 2);
    /* call */
    SDL_RWops* ret = SDL_RWFromFP(*pf, autoclose);
    /* result */
    tolua_pushusertype(L, (void*)ret, "SDL_RWops");
    return 1;
}

/* ================================================================== */
/*
 * get_SDL_Rect_array implements SDL_Rect[]
 */
/* ================================================================== */

static int get_SDL_Rect_array(lua_State* L)
{
#ifndef TOLUA_RELEASE
    tolua_Error tolua_err;
    if (!tolua_isusertype(L, 1, "SDL_Rect[]", 0, &tolua_err) ||
        !tolua_isnumber(L, 2, 0, &tolua_err))
        goto tolua_lerror;
    else
#endif
    {
        SDL_Rect** list = (SDL_Rect**)tolua_tousertype(L, 1, 0);
        int index = tolua_tonumber(L, 2, 0);
        SDL_Rect* rect = *(list + index);
        if (rect) {
            tolua_pushusertype(L, (void*)rect, "SDL_Rect");
        } else {
            lua_pushnil(L);
        }
    }
    return 1;
#ifndef TOLUA_RELEASE
tolua_lerror:
    tolua_error(L, "#ferror in function 'get_SDL_Rect_array'.", &tolua_err);
    return 0;
#endif
}

/* ================================================================== */
/*
 * SDL.SDL_ListModes(format, flags) returns result
 * type(result) = table of SDL_Rect struct
 * type(format) = SDL_PixelFormat struct
 *
 * returns 0 if no dimensions available
 * returns -1 if there are no dimension restrictions
 * returns SDL_Rect[] otherwise, use by indexing
 */
/* ================================================================== */

static int _SDL_ListModes(lua_State* L)
{
#ifndef TOLUA_RELEASE
    tolua_Error tolua_err;
    if (!tolua_isusertype(L, 1, "SDL_PixelFormat", 0, &tolua_err) ||
        !tolua_isnumber(L, 2, 0, &tolua_err) ||
        !tolua_isnoobj(L, 3, &tolua_err))
        goto tolua_lerror;
    else
#endif
    {
        SDL_PixelFormat* format = (SDL_PixelFormat*)tolua_tousertype(L, 1, 0);
        unsigned int flags = (unsigned int)tolua_tonumber(L, 2, 0);
        SDL_Rect** modes = SDL_ListModes(format, flags);

        if (modes == (SDL_Rect**)0) {  /* check if any modes available */
            lua_pushnumber(L, 0);
        } else if (modes == (SDL_Rect**)-1) {  /* check if no restrictions */
            lua_pushnumber(L, -1);
        } else {  /* create a table and fill with list of rects */
            tolua_pushusertype(L, (void*)modes, "SDL_Rect[]");
        }
    }
    return 1;
#ifndef TOLUA_RELEASE
tolua_lerror:
    tolua_error(L, "#ferror in function 'SDL_ListModes'.", &tolua_err);
    return 0;
#endif
}

/* ================================================================== */
/*
 * get_UDPpacket_array implements UDPpacket[]
 */
/* ================================================================== */

static int get_UDPpacket_array(lua_State* L)
{
#ifndef TOLUA_RELEASE
    tolua_Error tolua_err;
    if (!tolua_isusertype(L, 1, "UDPpacket[]", 0, &tolua_err) ||
        !tolua_isnumber(L, 2, 0, &tolua_err))
        goto tolua_lerror;
    else
#endif
    {
        UDPpacket** vec = (UDPpacket**)tolua_tousertype(L, 1, 0);
        int index = tolua_tonumber(L, 2, 0);
        UDPpacket* pkt = *(vec + index);
        if (pkt) {
            tolua_pushusertype(L, (void*)pkt, "UDPpacket");
        } else {
            lua_pushnil(L);
        }
    }
    return 1;
#ifndef TOLUA_RELEASE
tolua_lerror:
    tolua_error(L, "#ferror in function 'get_UDPpacket_array'.", &tolua_err);
    return 0;
#endif
}

/* ================================================================== */
/*
 * get_Uint8_array implements Uint8[]
 */
/* ================================================================== */

static int get_Uint8_array(lua_State* L)
{
#ifndef TOLUA_RELEASE
    tolua_Error tolua_err;
    if (!tolua_isusertype(L, 1, "Uint8[]", 0, &tolua_err) ||
        !tolua_isnumber(L, 2, 0, &tolua_err))
        goto tolua_lerror;
    else
#endif
    {
        Uint8* array = (Uint8*)tolua_tousertype(L, 1, 0);
        int index = tolua_tonumber(L, 2, 0);
        Uint8 value = array[index];
        tolua_pushnumber(L, (lua_Number)value);
    }
    return 1;
#ifndef TOLUA_RELEASE
tolua_lerror:
    tolua_error(L, "#ferror in function 'get_Uint8_array'.", &tolua_err);
    return 0;
#endif
}

/* ================================================================== */
/*
 * set_Uint8_array implements Uint8[]
 */
/* ================================================================== */

static int set_Uint8_array(lua_State* L)
{
#ifndef TOLUA_RELEASE
    tolua_Error tolua_err;
    if (!tolua_isusertype(L, 1, "Uint8[]", 0, &tolua_err) ||
        !tolua_isnumber(L, 2, 0, &tolua_err) ||
        !tolua_isnumber(L, 3, 0, &tolua_err))
        goto tolua_lerror;
    else
#endif
    {
        Uint8* array = (Uint8*)tolua_tousertype(L, 1, 0);
        int index = tolua_tonumber(L, 2, 0);
        Uint8 value = (Uint8)tolua_tonumber(L, 3, 0);
        array[index] = value;
    }
    return 0;
#ifndef TOLUA_RELEASE
tolua_lerror:
    tolua_error(L, "#ferror in function 'set_Uint8_array'.", &tolua_err);
    return 0;
#endif
}

/* ================================================================== */
/*
 * get_Uint16_array implements Uint16[]
 */
/* ================================================================== */

static int get_Uint16_array(lua_State* L)
{
#ifndef TOLUA_RELEASE
    tolua_Error tolua_err;
    if (!tolua_isusertype(L, 1, "Uint16[]", 0, &tolua_err) ||
        !tolua_isnumber(L, 2, 0, &tolua_err))
        goto tolua_lerror;
    else
#endif
    {
        Uint16* array = (Uint16*)tolua_tousertype(L, 1, 0);
        int index = tolua_tonumber(L, 2, 0);
        Uint16 value = array[index];
        tolua_pushnumber(L, (lua_Number)value);
    }
    return 1;
#ifndef TOLUA_RELEASE
tolua_lerror:
    tolua_error(L, "#ferror in function 'get_Uint16_array'.", &tolua_err);
    return 0;
#endif
}

/* ================================================================== */
/*
 * set_Uint16_array implements Uint16[]
 */
/* ================================================================== */

static int set_Uint16_array(lua_State* L)
{
#ifndef TOLUA_RELEASE
    tolua_Error tolua_err;
    if (!tolua_isusertype(L, 1, "Uint16[]", 0, &tolua_err) ||
        !tolua_isnumber(L, 2, 0, &tolua_err) ||
        !tolua_isnumber(L, 3, 0, &tolua_err))
        goto tolua_lerror;
    else
#endif
    {
        Uint16* array = (Uint16*)tolua_tousertype(L, 1, 0);
        int index = tolua_tonumber(L, 2, 0);
        Uint16 value = (Uint16)tolua_tonumber(L, 3, 0);
        array[index] = value;
    }
    return 0;
#ifndef TOLUA_RELEASE
tolua_lerror:
    tolua_error(L, "#ferror in function 'set_Uint16_array'.", &tolua_err);
    return 0;
#endif
}

/* ================================================================== */
/*
 * get_Uint32_array implements Uint32[]
 */
/* ================================================================== */

static int get_Uint32_array(lua_State* L)
{
#ifndef TOLUA_RELEASE
    tolua_Error tolua_err;
    if (!tolua_isusertype(L, 1, "Uint32[]", 0, &tolua_err) ||
        !tolua_isnumber(L, 2, 0, &tolua_err))
        goto tolua_lerror;
    else
#endif
    {
        Uint32* array = (Uint32*)tolua_tousertype(L, 1, 0);
        int index = tolua_tonumber(L, 2, 0);
        Uint32 value = array[index];
        tolua_pushnumber(L, (lua_Number)value);
    }
    return 1;
#ifndef TOLUA_RELEASE
tolua_lerror:
    tolua_error(L, "#ferror in function 'get_Uint32_array'.", &tolua_err);
    return 0;
#endif
}

/* ================================================================== */
/*
 * set_Uint32_array implements Uint32[]
 */
/* ================================================================== */

static int set_Uint32_array(lua_State* L)
{
#ifndef TOLUA_RELEASE
    tolua_Error tolua_err;
    if (!tolua_isusertype(L, 1, "Uint32[]", 0, &tolua_err) ||
        !tolua_isnumber(L, 2, 0, &tolua_err) ||
        !tolua_isnumber(L, 3, 0, &tolua_err))
        goto tolua_lerror;
    else
#endif
    {
        Uint32* array = (Uint32*)tolua_tousertype(L, 1, 0);
        int index = tolua_tonumber(L, 2, 0);
        Uint32 value = (Uint32)tolua_tonumber(L, 3, 0);
        array[index] = value;
    }
    return 0;
#ifndef TOLUA_RELEASE
tolua_lerror:
    tolua_error(L, "#ferror in function 'set_Uint32_array'.", &tolua_err);
    return 0;
#endif
}

/* ================================================================== */
/*
 * SDL.SDL_GetKeyState() returns Uint8[], numkeys
 */
/* ================================================================== */

static int _SDL_GetKeyState(lua_State* L)
{
#ifndef TOLUA_RELEASE
    tolua_Error tolua_err;
    if (!tolua_isnumber(L, 1, 1, &tolua_err) ||
        !tolua_isnoobj(L, 2, &tolua_err))
        goto tolua_lerror;
    else
#endif
    {
        int numkeys = (int)tolua_tonumber(L, 1, 0);
        void* list = (void*)SDL_GetKeyState(&numkeys);
        tolua_pushusertype(L, list, "Uint8[]");
        tolua_pushnumber(L, (lua_Number)numkeys);
    }
    return 2;
#ifndef TOLUA_RELEASE
tolua_lerror:
    tolua_error(L, "#ferror in function 'SDL_GetKeyState'.", &tolua_err);
    return 0;
#endif
}

/* ================================================================== */
/*
 * SDL.SDL_UpdateRects(screen, numrects, rects)
 * - rects can be either:
 *   (a) a single SDL_Rect, or
 *   (b) a regular array of SDL_Rect (indexed from 0 or 1)
 * - numrects must be a valid, will be used to allocate memory
 * - if table contains non-SDL_Rect, or some problem is encountered,
 *   this function may fail silently
 */
/* ================================================================== */

static int _SDL_UpdateRects(lua_State* L)
{
    tolua_Error tolua_err;
#ifndef TOLUA_RELEASE
    if (!tolua_isusertype(L, 1, "SDL_Surface", 0, &tolua_err) ||
        !tolua_isnumber(L, 2, 0, &tolua_err) ||
        (!tolua_isusertype(L, 3, "SDL_Rect", 0, &tolua_err) &&
         !tolua_istable(L, 3, 0, &tolua_err)) ||
        !tolua_isnoobj(L,4,&tolua_err))
        goto tolua_lerror;
    else
#endif
    {
        SDL_Rect* rects;
        SDL_Rect* dst;
        SDL_Rect* blk = 0;
        SDL_Surface* screen = (SDL_Surface*)tolua_tousertype(L, 1, 0);
        int numrects = (int)tolua_tonumber(L, 2, 0);
        if (lua_istable(L, 3)) {
            /* handle a table of SDL_Rect */
            int i = 0;
            int c = numrects;
            if (c <= 0) return 0;
            blk = (SDL_Rect*)SDL_malloc(sizeof(SDL_Rect) * numrects);
            if (!blk) return 0;
            rects = dst = blk;
            numrects = 0;
            /* grab SDL_Rects from table and dump into a single block */
            while (c) {
                lua_rawgeti(L, 3, i);
                if (lua_isnil(L, 4)) {
                    /* t[i] not valid, ignore for index 0 */
                    if (i != 0) break;  /* exit early if other nils */
                } else {
                    /* possibly insert SDL_Rect in t[i] into blk */
                    if (!tolua_isusertype(L, 4, "SDL_Rect", 0, &tolua_err))
                        break;
                    SDL_Rect* src = (SDL_Rect*)tolua_tousertype(L, 4, 0);
                    SDL_memcpy(dst++, src, sizeof(SDL_Rect));
                    c--; numrects++;
                }
                lua_pop(L, 1);
                i++;
            }
            lua_settop(L, 3);
        } else {
            /* a single SDL_Rect passed */
            rects = (SDL_Rect*)tolua_tousertype(L, 3, 0);
        }
        if (numrects > 0) SDL_UpdateRects(screen, numrects, rects);
        if (blk) SDL_free(blk);
    }
    return 0;
#ifndef TOLUA_RELEASE
tolua_lerror:
    tolua_error(L, "#ferror in function 'SDL_UpdateRects'.", &tolua_err);
    return 0;
#endif
}

/* ================================================================== */
/*
 * SDL.SDL_GetPixel(surface, x, y) returns pixel
 * - public domain code shamelessly copied from the SDL documentation
 *   the surface must be locked before direct pixel access
 */
/* ================================================================== */

Uint32 SDL_GetPixel(SDL_Surface *surface, int x, int y)
{
    int bpp = surface->format->BytesPerPixel;
    Uint8 *p = (Uint8 *)surface->pixels + y * surface->pitch + x * bpp;
    switch(bpp) {
    case 1: return *p;
    case 2: return *(Uint16 *)p;
    case 3: if(SDL_BYTEORDER == SDL_BIG_ENDIAN)
                return p[0] << 16 | p[1] << 8 | p[2];
            else
                return p[0] | p[1] << 8 | p[2] << 16;
    case 4: return *(Uint32 *)p;
    default: return 0;
    }
}

/* ================================================================== */
/*
 * SDL.SDL_PutPixel(surface, x, y, pixel)
 * - public domain code shamelessly copied from the SDL documentation
 *   the surface must be locked before direct pixel access
 */
/* ================================================================== */

void SDL_PutPixel(SDL_Surface *surface, int x, int y, Uint32 pixel)
{
    int bpp = surface->format->BytesPerPixel;
    Uint8 *p = (Uint8 *)surface->pixels + y * surface->pitch + x * bpp;
    switch(bpp) {
    case 1: *p = pixel;
            break;
    case 2: *(Uint16 *)p = pixel;
            break;
    case 3: if(SDL_BYTEORDER == SDL_BIG_ENDIAN) {
                p[0] = (pixel >> 16) & 0xff;
                p[1] = (pixel >> 8) & 0xff;
                p[2] = pixel & 0xff;
            } else {
                p[0] = pixel & 0xff;
                p[1] = (pixel >> 8) & 0xff;
                p[2] = (pixel >> 16) & 0xff;
            }
            break;
    case 4: *(Uint32 *)p = pixel;
            break;
    }
}

/* ================================================================== */
/*
 * SDL.SDL_malloc_local(size|string, data_type)
 *
 * Create a Lua-managed memory block from a string, or a size
 * specification, optionally tagging it with a tolua data type.
 * Memory block will be garbage-collected when no longer in use.
 * Blocks initialized using a size will be zeroed.
 */
/* ================================================================== */

static int SDL_malloc_local(lua_State* L)
{
#ifndef TOLUA_RELEASE
    tolua_Error tolua_err;
    if ((!tolua_isnumber(L, 1, 0, &tolua_err) &&
         !tolua_isstring(L, 1, 0, &tolua_err)) ||
        !tolua_isstring(L, 2, 1, &tolua_err) ||
        !tolua_isnoobj(L, 3, &tolua_err))
        goto tolua_lerror;
    else
#endif
    {
        size_t sz = 0;
        const char *dat = 0;
        const char *typ = 0;
        /* retrieve string to copy or size to allocate, optional data type */
        if (lua_type(L, 1) == LUA_TSTRING) {
            dat = luaL_checklstring(L, 1, &sz);
        } else if (lua_type(L, 1) == LUA_TNUMBER) {
            sz = luaL_checkinteger(L, 1);
        } else {
            return 0;
        }
        if (sz <= 0) return 0;
        typ = tolua_tostring(L, 2, "Uint8[]");
        /*  build the memory block, perform necessary operations */
        void *mem = SDL_malloc(sz);
        if (!mem) return 0;
        /* copy over data in string, set data type */
        if (dat) {
            SDL_memcpy(mem, dat, sz);
        } else {
            SDL_memset(mem, 0, sz);
        }
        tolua_pushusertype(L, mem, typ);
        tolua_register_gc(L, lua_gettop(L));
        return 1;
    }
#ifndef TOLUA_RELEASE
tolua_lerror:
    tolua_error(L, "#ferror in function 'SDL_malloc_local'.", &tolua_err);
    return 0;
#endif
}

/* ================================================================== */
/*
 * SDL.SDL_strtomem(str, data_type)
 * SDL.SDL_memtostr(mem, size)
 * - converts between memory blocks and strings
 * - SDL_strtomem is an alias of SDL_malloc_local, that is, it
 *   returns a Lua-managed memory block
 */
/* ================================================================== */

static int SDL_memtostr(lua_State* L)
{
#ifndef TOLUA_RELEASE
    tolua_Error tolua_err;
    if (!tolua_isuserdata(L, 1, 0, &tolua_err) ||
        !tolua_isnumber(L, 2, 0, &tolua_err) ||
        !tolua_isnoobj(L, 3, &tolua_err))
        goto tolua_lerror;
    else
#endif
    {
        const void *mem = (const void*)tolua_touserdata(L, 1, 0);
        size_t sz = (size_t)tolua_tonumber(L, 2, 0);
        if (!mem || sz < 0) return 0;
        lua_pushlstring(L, (const char *)mem, sz);
        return 1;
    }
#ifndef TOLUA_RELEASE
tolua_lerror:
    tolua_error(L, "#ferror in function 'SDL_memtostr'.", &tolua_err);
    return 0;
#endif
}

/* ================================================================== */
/*
 * SDL.AddTimer(interval, event)
 * replacement call for SDL_AddTimer; implements limited callback
 * functionality so that SDL_AddTimer and SDL_RemoveTimer can be used
 */
/* ================================================================== */

Uint32 LuaSDL_NewTimerCallback(Uint32 interval, void *param)
{
    SDL_PushEvent((SDL_Event *)param);
    return interval;
}

SDL_TimerID _SDL_AddTimer(Uint32 interval, SDL_Event *param)
{
    return SDL_AddTimer(interval, LuaSDL_NewTimerCallback, (void *)param);
}

/* ================================================================== */
/*
 * wrappers for SDL_LoadWAV_RW and SDL_LoadWAV to avoid casting issues
 * a quick-and-dirty workaround, may not be required in the future
 */
/* ================================================================== */

SDL_AudioSpec * _SDL_LoadWAV_RW(SDL_RWops *src, int freesrc, SDL_AudioSpec *spec,
                                void **audio_buf, Uint32 *audio_len)
{
    return SDL_LoadWAV_RW(src, freesrc, spec, (Uint8 **)audio_buf, audio_len);
}

SDL_AudioSpec * _SDL_LoadWAV(const char *file, SDL_AudioSpec *spec,
    void **audio_buf, Uint32 *audio_len)
{
    return SDL_LoadWAV(file, spec, (Uint8 **)audio_buf, audio_len);
}

/* ================================================================== */
/*
 * SDL.LuaSDL_AudioCallback
 * - callback, lightusertype (C function) for pushing audio data
 *
 * SDL.LuaSDL_AudioCh1(audio_buf, audio_len[, loop[, volume]])
 * SDL.LuaSDL_AudioCh2(audio_buf, audio_len[, loop[, volume]])
 * - set audio buffers
 * - audio loops continuously if loop~=0, loop=0 by default
 * - volume when mixing, volume=SDL_MIX_MAXVOLUME by default
 */
/* ================================================================== */

struct LuaSDL_Audio_Data {
    Uint8* buf;
    int len;
    int pos;
    int loop, volume;
} audio1, audio2;

void mixin(struct LuaSDL_Audio_Data* audio, Uint8 *stream, int len)
{
    int wavleft, seg;
    if (audio->len == 0) return;        /* no wav or no loop */
    wavleft = audio->len - audio->pos;
    while (len) {
        seg = (wavleft > len) ? len:wavleft;
        SDL_MixAudio(stream, audio->buf + audio->pos, seg, audio->volume);
        stream += seg;
        audio->pos += seg;
        len -= seg;
        wavleft -= seg;
        if (wavleft == 0) {             /* end of sample handling */
            if (audio->loop) {          /* loop sample */
                audio->pos = 0;
                wavleft = audio->len;
            } else {                    /* disable */
                audio->len = 0;
                break;
            }
        }
    } /* while */
}

void LuaSDL_AudioCallback(void *unused, Uint8 *stream, int len)
{
    mixin(&audio1, stream, len);
    mixin(&audio2, stream, len);
}

void LuaSDL_AudioCh1(void *audio_buf, Uint32 audio_len, int loop, int volume)
{
    SDL_LockAudio();
    audio1.buf = (Uint8 *)audio_buf;
    audio1.len = audio_len;
    audio1.pos = 0;
    audio1.loop = loop;
    audio1.volume = volume;
    SDL_UnlockAudio();
}

void LuaSDL_AudioCh2(void *audio_buf, Uint32 audio_len, int loop, int volume)
{
    SDL_LockAudio();
    audio2.buf = (Uint8 *)audio_buf;
    audio2.len = audio_len;
    audio2.pos = 0;
    audio2.loop = loop;
    audio2.volume = volume;
    SDL_UnlockAudio();
}

/* ================================================================== */
/*
 * Memory management, if malloc returns NULL, let the Lua script fail
 */
/* ================================================================== */

SDL_AudioSpec* SDL_AudioSpec_new(void)
{
    SDL_AudioSpec* obj = (SDL_AudioSpec*)SDL_malloc(sizeof(SDL_AudioSpec));
    return obj;
}
void SDL_AudioSpec_delete(SDL_AudioSpec *obj)
{
    SDL_free(obj);
}

/* SDL_AudioSpec_local adapted from generated binding code */
static int SDL_AudioSpec_local(lua_State* L)
{
#ifndef TOLUA_RELEASE
    tolua_Error err;
    if (!tolua_isnoobj(L, 1, &err)) goto lerror; else
#endif
    {
        SDL_AudioSpec* obj = (SDL_AudioSpec*)SDL_malloc(sizeof(SDL_AudioSpec));
        tolua_pushusertype(L, (void*) obj, "SDL_AudioSpec");
        tolua_register_gc(L, lua_gettop(L));
    }
    return 1;
#ifndef TOLUA_RELEASE
    lerror:
    tolua_error(L, "#ferror in function 'SDL_AudioSpec_local'.", &err);
    return 0;
#endif
}

/* ================================================================== */

SDL_AudioCVT* SDL_AudioCVT_new(void)
{
    SDL_AudioCVT* obj = (SDL_AudioCVT*)SDL_malloc(sizeof(SDL_AudioCVT));
    return obj;
}
void SDL_AudioCVT_delete(SDL_AudioCVT *obj)
{
    SDL_free(obj);
}

/* SDL_AudioCVT_local adapted from generated binding code */
static int SDL_AudioCVT_local(lua_State* L)
{
#ifndef TOLUA_RELEASE
    tolua_Error err;
    if (!tolua_isnoobj(L, 1, &err)) goto lerror; else
#endif
    {
        SDL_AudioCVT* obj = (SDL_AudioCVT*)SDL_malloc(sizeof(SDL_AudioCVT));
        tolua_pushusertype(L, (void*) obj, "SDL_AudioCVT");
        tolua_register_gc(L, lua_gettop(L));
    }
    return 1;
#ifndef TOLUA_RELEASE
    lerror:
    tolua_error(L, "#ferror in function 'SDL_AudioCVT_local'.", &err);
    return 0;
#endif
}

/* ================================================================== */

SDL_CDtrack* SDL_CDtrack_new(void)
{
    SDL_CDtrack* obj = (SDL_CDtrack*)SDL_malloc(sizeof(SDL_CDtrack));
    return obj;
}
void SDL_CDtrack_delete(SDL_CDtrack *obj)
{
    SDL_free(obj);
}

/* SDL_CDtrack_local adapted from generated binding code */
static int SDL_CDtrack_local(lua_State* L)
{
#ifndef TOLUA_RELEASE
    tolua_Error err;
    if (!tolua_isnoobj(L, 1, &err)) goto lerror; else
#endif
    {
        SDL_CDtrack* obj = (SDL_CDtrack*)SDL_malloc(sizeof(SDL_CDtrack));
        tolua_pushusertype(L, (void*) obj, "SDL_CDtrack");
        tolua_register_gc(L, lua_gettop(L));
    }
    return 1;
#ifndef TOLUA_RELEASE
    lerror:
    tolua_error(L, "#ferror in function 'SDL_CDtrack_local'.", &err);
    return 0;
#endif
}

/* ================================================================== */

SDL_CD* SDL_CD_new(void)
{
    SDL_CD* obj = (SDL_CD*)SDL_malloc(sizeof(SDL_CD));
    return obj;
}
void SDL_CD_delete(SDL_CD *obj)
{
    SDL_free(obj);
}

/* SDL_CD_local adapted from generated binding code */
static int SDL_CD_local(lua_State* L)
{
#ifndef TOLUA_RELEASE
    tolua_Error err;
    if (!tolua_isnoobj(L, 1, &err)) goto lerror; else
#endif
    {
        SDL_CD* obj = (SDL_CD*)SDL_malloc(sizeof(SDL_CD));
        tolua_pushusertype(L, (void*) obj, "SDL_CD");
        tolua_register_gc(L, lua_gettop(L));
    }
    return 1;
#ifndef TOLUA_RELEASE
    lerror:
    tolua_error(L, "#ferror in function 'SDL_CD_local'.", &err);
    return 0;
#endif
}

/* ================================================================== */

SDL_Event* SDL_Event_new(void)
{
    SDL_Event* obj = (SDL_Event*)SDL_malloc(sizeof(SDL_Event));
    return obj;
}
void SDL_Event_delete(SDL_Event *obj)
{
    SDL_free(obj);
}

/* SDL_Event_local adapted from generated binding code */
static int SDL_Event_local(lua_State* L)
{
#ifndef TOLUA_RELEASE
    tolua_Error err;
    if (!tolua_isnoobj(L, 1, &err)) goto lerror; else
#endif
    {
        SDL_Event* obj = (SDL_Event*)SDL_malloc(sizeof(SDL_Event));
        tolua_pushusertype(L, (void*) obj, "SDL_Event");
        tolua_register_gc(L, lua_gettop(L));
    }
    return 1;
#ifndef TOLUA_RELEASE
    lerror:
    tolua_error(L, "#ferror in function 'SDL_Event_local'.", &err);
    return 0;
#endif
}

/* ================================================================== */

SDL_keysym* SDL_keysym_new(void)
{
    SDL_keysym* obj = (SDL_keysym*)SDL_malloc(sizeof(SDL_keysym));
    return obj;
}
void SDL_keysym_delete(SDL_keysym *obj)
{
    SDL_free(obj);
}

/* SDL_keysym_local adapted from generated binding code */
static int SDL_keysym_local(lua_State* L)
{
#ifndef TOLUA_RELEASE
    tolua_Error err;
    if (!tolua_isnoobj(L, 1, &err)) goto lerror; else
#endif
    {
        SDL_keysym* obj = (SDL_keysym*)SDL_malloc(sizeof(SDL_keysym));
        tolua_pushusertype(L, (void*) obj, "SDL_keysym");
        tolua_register_gc(L, lua_gettop(L));
    }
    return 1;
#ifndef TOLUA_RELEASE
    lerror:
    tolua_error(L, "#ferror in function 'SDL_keysym_local'.", &err);
    return 0;
#endif
}

/* ================================================================== */

SDL_Cursor* SDL_Cursor_new(void)
{
    SDL_Cursor* obj = (SDL_Cursor*)SDL_malloc(sizeof(SDL_Cursor));
    return obj;
}
void SDL_Cursor_delete(SDL_Cursor *obj)
{
    SDL_free(obj);
}

/* SDL_Cursor_local adapted from generated binding code */
static int SDL_Cursor_local(lua_State* L)
{
#ifndef TOLUA_RELEASE
    tolua_Error err;
    if (!tolua_isnoobj(L, 1, &err)) goto lerror; else
#endif
    {
        SDL_Cursor* obj = (SDL_Cursor*)SDL_malloc(sizeof(SDL_Cursor));
        tolua_pushusertype(L, (void*) obj, "SDL_Cursor");
        tolua_register_gc(L, lua_gettop(L));
    }
    return 1;
#ifndef TOLUA_RELEASE
    lerror:
    tolua_error(L, "#ferror in function 'SDL_Cursor_local'.", &err);
    return 0;
#endif
}

/* ================================================================== */

IPaddress* IPaddress_new(void)
{
    IPaddress* obj = (IPaddress*)SDL_malloc(sizeof(IPaddress));
    return obj;
}
void IPaddress_delete(IPaddress *obj)
{
    SDL_free(obj);
}

/* IPaddress_local adapted from generated binding code */
static int IPaddress_local(lua_State* L)
{
#ifndef TOLUA_RELEASE
    tolua_Error err;
    if (!tolua_isnoobj(L, 1, &err)) goto lerror; else
#endif
    {
        IPaddress* obj = (IPaddress*)SDL_malloc(sizeof(IPaddress));
        tolua_pushusertype(L, (void*) obj, "IPaddress");
        tolua_register_gc(L, lua_gettop(L));
    }
    return 1;
#ifndef TOLUA_RELEASE
    lerror:
    tolua_error(L, "#ferror in function 'IPaddress_local'.", &err);
    return 0;
#endif
}

/* ================================================================== */

SDL_version* SDL_version_new(void)
{
    SDL_version* obj = (SDL_version*)SDL_malloc(sizeof(SDL_version));
    return obj;
}
void SDL_version_delete(SDL_version *obj)
{
    SDL_free(obj);
}

/* SDL_version_local adapted from generated binding code */
static int SDL_version_local(lua_State* L)
{
#ifndef TOLUA_RELEASE
    tolua_Error err;
    if (!tolua_isnoobj(L, 1, &err)) goto lerror; else
#endif
    {
        SDL_version* obj = (SDL_version*)SDL_malloc(sizeof(SDL_version));
        tolua_pushusertype(L, (void*) obj, "SDL_version");
        tolua_register_gc(L, lua_gettop(L));
    }
    return 1;
#ifndef TOLUA_RELEASE
    lerror:
    tolua_error(L, "#ferror in function 'SDL_version_local'.", &err);
    return 0;
#endif
}

/* ================================================================== */

SDL_Rect* SDL_Rect_new(void)
{
    SDL_Rect* obj = (SDL_Rect*)SDL_malloc(sizeof(SDL_Rect));
    return obj;
}
void SDL_Rect_delete(SDL_Rect *obj)
{
    SDL_free(obj);
}

/* SDL_Rect_local adapted from generated binding code */
static int SDL_Rect_local(lua_State* L)
{
#ifndef TOLUA_RELEASE
    tolua_Error err;
    if (!tolua_isnoobj(L, 1, &err)) goto lerror; else
#endif
    {
        SDL_Rect* obj = (SDL_Rect*)SDL_malloc(sizeof(SDL_Rect));
        tolua_pushusertype(L, (void*) obj, "SDL_Rect");
        tolua_register_gc(L, lua_gettop(L));
    }
    return 1;
#ifndef TOLUA_RELEASE
    lerror:
    tolua_error(L, "#ferror in function 'SDL_Rect_local'.", &err);
    return 0;
#endif
}

/* ================================================================== */

SDL_Color* SDL_Color_new(void)
{
    SDL_Color* obj = (SDL_Color*)SDL_malloc(sizeof(SDL_Color));
    return obj;
}
void SDL_Color_delete(SDL_Color *obj)
{
    SDL_free(obj);
}

/* SDL_Color_local adapted from generated binding code */
static int SDL_Color_local(lua_State* L)
{
#ifndef TOLUA_RELEASE
    tolua_Error err;
    if (!tolua_isnoobj(L, 1, &err)) goto lerror; else
#endif
    {
        SDL_Color* obj = (SDL_Color*)SDL_malloc(sizeof(SDL_Color));
        tolua_pushusertype(L, (void*) obj, "SDL_Color");
        tolua_register_gc(L, lua_gettop(L));
    }
    return 1;
#ifndef TOLUA_RELEASE
    lerror:
    tolua_error(L, "#ferror in function 'SDL_Color_local'.", &err);
    return 0;
#endif
}

/* ================================================================== */

SDL_PixelFormat* SDL_PixelFormat_new(void)
{
    SDL_PixelFormat* obj = (SDL_PixelFormat*)SDL_malloc(sizeof(SDL_PixelFormat));
    return obj;
}
void SDL_PixelFormat_delete(SDL_PixelFormat *obj)
{
    SDL_free(obj);
}

/* SDL_PixelFormat_local adapted from generated binding code */
static int SDL_PixelFormat_local(lua_State* L)
{
#ifndef TOLUA_RELEASE
    tolua_Error err;
    if (!tolua_isnoobj(L, 1, &err)) goto lerror; else
#endif
    {
        SDL_PixelFormat* obj = (SDL_PixelFormat*)SDL_malloc(sizeof(SDL_PixelFormat));
        tolua_pushusertype(L, (void*) obj, "SDL_PixelFormat");
        tolua_register_gc(L, lua_gettop(L));
    }
    return 1;
#ifndef TOLUA_RELEASE
    lerror:
    tolua_error(L, "#ferror in function 'SDL_PixelFormat_local'.", &err);
    return 0;
#endif
}

/* ================================================================== */

/* NOTE: not required, user never needs to set one up directly */
/*
SDL_Surface* SDL_Surface_new(void)
{
    SDL_Surface* obj = (SDL_Surface*)SDL_malloc(sizeof(SDL_Surface));
    return obj;
}
void SDL_Surface_delete(SDL_Surface *obj)
{
    SDL_free(obj);
}
*/

/* NOTE: not required, user never needs to set one up directly */
/* SDL_Surface_local adapted from generated binding code */
/*
static int SDL_Surface_local(lua_State* L)
{
#ifndef TOLUA_RELEASE
    tolua_Error err;
    if (!tolua_isnoobj(L, 1, &err)) goto lerror; else
#endif
    {
        SDL_Surface* obj = (SDL_Surface*)SDL_malloc(sizeof(SDL_Surface));
        tolua_pushusertype(L, (void*) obj, "SDL_Surface");
        tolua_register_gc(L, lua_gettop(L));
    }
    return 1;
#ifndef TOLUA_RELEASE
    lerror:
    tolua_error(L, "#ferror in function 'SDL_Surface_local'.", &err);
    return 0;
#endif
}
*/

/* ================================================================== */

SDL_VideoInfo* SDL_VideoInfo_new(void)
{
    SDL_VideoInfo* obj = (SDL_VideoInfo*)SDL_malloc(sizeof(SDL_VideoInfo));
    return obj;
}
void SDL_VideoInfo_delete(SDL_VideoInfo *obj)
{
    SDL_free(obj);
}

/* SDL_VideoInfo_local adapted from generated binding code */
static int SDL_VideoInfo_local(lua_State* L)
{
#ifndef TOLUA_RELEASE
    tolua_Error err;
    if (!tolua_isnoobj(L, 1, &err)) goto lerror; else
#endif
    {
        SDL_VideoInfo* obj = (SDL_VideoInfo*)SDL_malloc(sizeof(SDL_VideoInfo));
        tolua_pushusertype(L, (void*) obj, "SDL_VideoInfo");
        tolua_register_gc(L, lua_gettop(L));
    }
    return 1;
#ifndef TOLUA_RELEASE
    lerror:
    tolua_error(L, "#ferror in function 'SDL_VideoInfo_local'.", &err);
    return 0;
#endif
}

/* ================================================================== */
/*
 * SDL.LuaSDL_lsdir(dirpath)
 * - returns a table of items in a directory, or nil
 * SDL.LuaSDL_mkdir(dirpath)
 * SDL.LuaSDL_chdir(dirpath)
 * SDL.LuaSDL_rmdir(dirpath)
 */
/* ================================================================== */

/* re-use Lua's loslib.c method of error handling */
static int LuaSDL_osresult(lua_State *L, int i, const char *path) {
    int en = errno;
    if (i) {
        lua_pushboolean(L, 1);
        return 1;
    }
    else {
        lua_pushnil(L);
        lua_pushfstring(L, "%s: %s", path, strerror(en));
        lua_pushinteger(L, en);
        return 3;
    }
}

/* ================================================================== */

static int LuaSDL_lsdir(lua_State* L)
{
#ifdef __WIN32__
    struct _finddata_t dat;
    const char *path = luaL_checkstring(L, 1);
    long handle = _findfirst(path, &dat);
    if (handle == -1) {
        return LuaSDL_osresult(L, 0, path);
    }
    int i = 1;
    lua_newtable(L);
    do {
        lua_pushstring(L, dat.name);
        lua_rawseti(L, -2, i++);
    } while (_findnext(handle, &dat) == 0);
    _findclose(handle);
    return 1;
#else
    //#error "please add code for non-Win32..."
    return 0;
#endif
}

/* ================================================================== */

static int LuaSDL_mkdir(lua_State* L)
{
    const char *path = luaL_checkstring(L, 1);
#ifdef __WIN32__
    return LuaSDL_osresult(L, CreateDirectory(path,NULL) == 0, path);
#else
    return LuaSDL_osresult(L, mkdir(path) == 0, path);
#endif
}

/* ================================================================== */

static int LuaSDL_chdir(lua_State* L)
{
    const char *path = luaL_checkstring(L, 1);
#ifdef __WIN32__
	return LuaSDL_osresult(L, SetCurrentDirectory(path) == 0, path);
#else
	return LuaSDL_osresult(L, chdir(path) == 0, path);
#endif
}

/* ================================================================== */

static int LuaSDL_rmdir(lua_State* L)
{
    const char *path = luaL_checkstring(L, 1);
#ifdef __WIN32__
    return LuaSDL_osresult(L, RemoveDirectory(path) == 0, path);
#else
    return LuaSDL_osresult(L, rmdir(path) == 0, path);
#endif
}

/* ================================================================== */
/*
 * SDL.LuaSDL_DirCfg constant table
 */
/* ================================================================== */

static int LuaSDL_DirCfg(lua_State* L)
{
#ifdef __WIN32__
    lua_newtable(L);
    char path[MAX_PATH];
    if (SUCCEEDED(SHGetFolderPath(NULL, CSIDL_APPDATA, NULL, 0, path))) {
        lua_pushstring(L, "APPDATA");
        lua_pushstring(L, path);
        lua_rawset(L, -3);
    }
    if (SUCCEEDED(SHGetFolderPath(NULL, CSIDL_PERSONAL, NULL, 0, path))) {
        lua_pushstring(L, "PERSONAL");
        lua_pushstring(L, path);
        lua_rawset(L, -3);
    }
    if (SUCCEEDED(SHGetFolderPath(NULL, CSIDL_LOCAL_APPDATA, NULL, 0, path))) {
        lua_pushstring(L, "LOCAL_APPDATA");
        lua_pushstring(L, path);
        lua_rawset(L, -3);
    }
    if (SUCCEEDED(SHGetFolderPath(NULL, CSIDL_COMMON_APPDATA, NULL, 0, path))) {
        lua_pushstring(L, "COMMON_APPDATA");
        lua_pushstring(L, path);
        lua_rawset(L, -3);
    }
    return 1;
#else
    //#error "please add code for non-Win32..."
    return 0;
#endif
}

/* ================================================================== */
/*
 * Open additional functionality for LuaSDL library
 */
/* ================================================================== */

TOLUA_API int luaopen_LuaSDL (lua_State* L)
{
	if (get_absolute_paths(&start_info)) {
        fprintf(stderr, "Error: absolute path too long.\n");
        fflush(stderr);
        exit(EXIT_FAILURE);
    }

    /* interface initialization */
    tolua_SDL_open(L);                  /* tolua++ bound stuff */
    tolua_module(L, NULL, 0);           /* push global scope */
    tolua_beginmodule(L, NULL);
    tolua_module(L, "SDL", 1);          /* push SDL scope */
    tolua_beginmodule(L,"SDL");
        /* start of additional SDL module functionality */

        /* useful functions and stuff*/
        tolua_function(L, "Bool", _SDL_bool);
        tolua_function(L, "And", SDL_and);
        tolua_function(L, "Or", SDL_or);
        tolua_function(L, "Xor", SDL_xor);
        tolua_function(L, "Not", SDL_not);
        tolua_function(L, "LShift", SDL_lshift);
        tolua_function(L, "RShift", SDL_rshift);
        tolua_sconstant(L, "LuaSDL_Version", LuaSDL_VERSION);

        /* data and memory management */
        tolua_function(L, "SDL_malloc_local", SDL_malloc_local);
        tolua_function(L, "SDL_strtomem", SDL_malloc_local);
        tolua_function(L, "SDL_memtostr", SDL_memtostr);

        /* SDL_audio.h */
        tolua_function(L, "SDL_AudioSpec_local", SDL_AudioSpec_local);
        tolua_function(L, "SDL_AudioCVT_local", SDL_AudioCVT_local);
        /* SDL_cdrom.h */
        tolua_function(L, "SDL_CDtrack_local", SDL_CDtrack_local);
        tolua_function(L, "SDL_CD_local", SDL_CD_local);
        /* SDL_events.h */
        tolua_function(L, "SDL_Event_local", SDL_Event_local);
        /* SDL_keyboard.h */
        tolua_function(L, "SDL_keysym_local", SDL_keysym_local);
        /* SDL_mouse.h */
        tolua_function(L, "SDL_Cursor_local", SDL_Cursor_local);
        /* SDL_net.h */
        tolua_function(L, "IPaddress_local", IPaddress_local);
        /* SDL_version.h */
        tolua_function(L, "SDL_version_local", SDL_version_local);
        /* SDL_video.h */
        tolua_function(L, "SDL_Rect_local", SDL_Rect_local);
        tolua_function(L, "SDL_Color_local", SDL_Color_local);
        tolua_function(L, "SDL_PixelFormat_local", SDL_PixelFormat_local);
        /* NOTE: not required, user never needs to set one up directly */
        /* tolua_function(L, "SDL_Surface_local", SDL_Surface_local); */
        tolua_function(L, "SDL_VideoInfo_local", SDL_VideoInfo_local);

        /* user experience */
        tolua_sconstant(L, "LuaSDL_DirSep", start_info.dir_sep);
        tolua_sconstant(L, "LuaSDL_DirCwd", start_info.dir_cwd);
        tolua_sconstant(L, "LuaSDL_DirExe", start_info.dir_exe);
        tolua_sconstant(L, "LuaSDL_DirApp", start_info.dir_app);
        tolua_sconstant(L, "LuaSDL_AppName", start_info.appname);
        tolua_sconstant(L, "LuaSDL_NotFound", start_info.notfound);
        /* embedded minimal font */
        tolua_pointer(L, "LuaSDL_FontBasic", (void *)sdllib_font);
        /* simple directory management */
        tolua_function(L, "LuaSDL_lsdir", LuaSDL_lsdir);
        tolua_function(L, "LuaSDL_mkdir", LuaSDL_mkdir);
        tolua_function(L, "LuaSDL_chdir", LuaSDL_chdir);
        tolua_function(L, "LuaSDL_rmdir", LuaSDL_rmdir);
        /* program configuration paths */
        lua_pushstring(L, "LuaSDL_DirCfg");
        LuaSDL_DirCfg(L);
        lua_rawset(L, -3);

        /* for SDL_audio.h */
        tolua_pointer(L, "LuaSDL_AudioCallback", (void *)LuaSDL_AudioCallback);
        /* for SDL_keyboard.h */
        tolua_usertype(L, "Uint8[]");
        tolua_cclass(L, "Uint8[]", "Uint8[]", "", NULL);
        tolua_beginmodule(L, "Uint8[]");
        tolua_function(L, "__index", get_Uint8_array);
        tolua_function(L, "__newindex", set_Uint8_array);
        tolua_endmodule(L);
        tolua_function(L, "SDL_GetKeyState", _SDL_GetKeyState);
        /* for SDL_net.h */
        tolua_usertype(L, "UDPpacket[]");
        tolua_cclass(L, "UDPpacket[]", "UDPpacket[]", "", NULL);
        tolua_beginmodule(L, "UDPpacket[]");
        tolua_function(L, "__index", get_UDPpacket_array);
        tolua_endmodule(L);
        /* for SDL_rwops.h */
        tolua_function(L, "SDL_RWFromFP", _SDL_RWFromFP);
        /* for SDL_stdinc.h */
        tolua_usertype(L, "Uint16[]");
        tolua_cclass(L, "Uint16[]", "Uint16[]", "", NULL);
        tolua_beginmodule(L, "Uint16[]");
        tolua_function(L, "__index", get_Uint16_array);
        tolua_function(L, "__newindex", set_Uint16_array);
        tolua_endmodule(L);
        tolua_usertype(L, "Uint32[]");
        tolua_cclass(L, "Uint32[]", "Uint32[]", "", NULL);
        tolua_beginmodule(L, "Uint32[]");
        tolua_function(L, "__index", get_Uint32_array);
        tolua_function(L, "__newindex", set_Uint32_array);
        tolua_endmodule(L);
        /* for SDL_video.h */
        tolua_usertype(L, "SDL_Rect[]");
        tolua_cclass(L, "SDL_Rect[]", "SDL_Rect[]", "", NULL);
        tolua_beginmodule(L, "SDL_Rect[]");
        tolua_function(L, "__index", get_SDL_Rect_array);
        tolua_endmodule(L);
        tolua_function(L, "SDL_ListModes", _SDL_ListModes);
        tolua_function(L, "SDL_UpdateRects", _SDL_UpdateRects);

        /* end of additional SDL module functionality */
    tolua_endmodule(L);                 /* pop SDL scope */
    tolua_endmodule(L);                 /* pop global scope */
    /* additional initialization */
    audio1.len = 0;                     /* reset audio buffers */
    audio2.len = 0;
    return 1;
}
